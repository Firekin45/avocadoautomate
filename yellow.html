<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Moving Background – Pipes Canvas</title>
  <style>
    html, body { height: 100%; margin: 0; }
    body { background: #020a07; color: #fff; font-family: system-ui, Arial, sans-serif; }
    /* This div is where the script will mount the canvases */
    .content--canvas { position: fixed; inset: 0; z-index: -1; }
    /* Optional foreground demo content so you can see it working */
    .content {
      position: relative; min-height: 100svh; display: grid; place-items: center;
      text-align: center; padding: 4vmin;
    }
    .card {
      background: rgba(0,0,0,.35); border: 1px solid rgba(255,255,255,.15);
      border-radius: 16px; padding: clamp(16px,4vmin,40px); backdrop-filter: blur(6px);
      max-width: 720px;
    }
  </style>
</head>
<body>

  <!-- Canvas background mount point -->
  <div class="content--canvas"></div>

 

  <script>
  'use strict';

  /* ==== Added: math constants + helpers that the snippet expects ==== */
  const TO_RAD = Math.PI / 180;
  const HALF_PI = Math.PI / 2;
  const TAU = Math.PI * 2;
  const rand = n => Math.random() * n;
  const round = n => Math.round(n);
  const cos = Math.cos;
  const sin = Math.sin;
  function fadeInOut(life, ttl) { // smooth in/out 0..1
    const t = life / ttl;
    return t < 0.5 ? (t / 0.5) : ((1 - t) / 0.5);
  }

  /* ==== Original snippet (slightly wrapped) ==== */
  const pipeCount = 30;
  const pipePropCount = 8;
  const pipePropsLength = pipeCount * pipePropCount;
  const turnCount = 8;
  const turnAmount = (360 / turnCount) * TO_RAD;
  const turnChanceRange = 58;
  const baseSpeed = 0.5;
  const rangeSpeed = 1;
  const baseTTL = 100;
  const rangeTTL = 300;
  const baseWidth = 2;
  const rangeWidth = 4;
  const baseHue = 180;
  const rangeHue = 60;
  const backgroundColor = 'hsla(150,80%,1%,1)';

  let container;
  let canvas;
  let ctx;
  let center;
  let tick;
  let pipeProps;

  function setup() {
    createCanvas();
    resize();
    initPipes();
    draw();
  }

  function initPipes() {
    pipeProps = new Float32Array(pipePropsLength);
    for (let i = 0; i < pipePropsLength; i += pipePropCount) {
      initPipe(i);
    }
  }

  function initPipe(i) {
    let x = rand(canvas.a.width);
    let y = center[1];
    let direction = (round(rand(1)) ? HALF_PI : TAU - HALF_PI);
    let speed = baseSpeed + rand(rangeSpeed);
    let life = 0;
    let ttl = baseTTL + rand(rangeTTL);
    let width = baseWidth + rand(rangeWidth);
    let hue = baseHue + rand(rangeHue);
    pipeProps.set([x, y, direction, speed, life, ttl, width, hue], i);
  }

  function updatePipes() {
    tick++;
    for (let i = 0; i < pipePropsLength; i += pipePropCount) updatePipe(i);
  }

  function updatePipe(i) {
    let i2=1+i, i3=2+i, i4=3+i, i5=4+i, i6=5+i, i7=6+i, i8=7+i;
    let x = pipeProps[i];
    let y = pipeProps[i2];
    let direction = pipeProps[i3];
    let speed = pipeProps[i4];
    let life = pipeProps[i5];
    let ttl = pipeProps[i6];
    let width = pipeProps[i7];
    let hue = pipeProps[i8];

    drawPipe(x, y, life, ttl, width, hue);

    life++;
    x += cos(direction) * speed;
    y += sin(direction) * speed;
    const turnChance = !(tick % round(rand(turnChanceRange))) && (!(round(x) % 6) || !(round(y) % 6));
    const turnBias = round(rand(1)) ? -1 : 1;
    direction += turnChance ? turnAmount * turnBias : 0;

    pipeProps[i] = x;
    pipeProps[i2] = y;
    pipeProps[i3] = direction;
    pipeProps[i5] = life;

    checkBounds(x, y);
    if (life > ttl) initPipe(i);
  }

  function drawPipe(x, y, life, ttl, width, hue) {
    ctx.a.save();
    ctx.a.strokeStyle = `hsla(${hue},75%,50%,${fadeInOut(life, ttl) * 0.125})`;
    ctx.a.beginPath();
    ctx.a.arc(x, y, width, 0, TAU);
    ctx.a.stroke();
    ctx.a.closePath();
    ctx.a.restore();
  }

  function checkBounds(x, y) {
    if (x > canvas.a.width) x = 0;
    if (x < 0) x = canvas.a.width;
    if (y > canvas.a.height) y = 0;
    if (y < 0) y = canvas.a.height;
  }

  function createCanvas() {
    container = document.querySelector('.content--canvas');
    if (!container) { // safety: create it if missing
      container = document.createElement('div');
      container.className = 'content--canvas';
      document.body.appendChild(container);
    }
    canvas = {
      a: document.createElement('canvas'),
      b: document.createElement('canvas')
    };
    // b is the displayed canvas
    canvas.b.style.cssText = `
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
    `;
    container.appendChild(canvas.b);
    ctx = {
      a: canvas.a.getContext('2d'),
      b: canvas.b.getContext('2d')
    };
    center = [];
    tick = 0;
  }

  function resize() {
    const { innerWidth, innerHeight } = window;

    canvas.a.width  = innerWidth;
    canvas.a.height = innerHeight;
    ctx.a.drawImage(canvas.b, 0, 0);

    canvas.b.width  = innerWidth;
    canvas.b.height = innerHeight;
    ctx.b.drawImage(canvas.a, 0, 0);

    center[0] = 0.5 * canvas.a.width;
    center[1] = 0.5 * canvas.a.height;
  }

  function render() {
    ctx.b.save();
    ctx.b.fillStyle = backgroundColor;
    ctx.b.fillRect(0,0,canvas.b.width,canvas.b.height);
    ctx.b.restore();

    ctx.b.save();
    ctx.b.filter = 'blur(12px)';
    ctx.b.drawImage(canvas.a, 0, 0);
    ctx.b.restore();

    ctx.b.save();
    ctx.b.drawImage(canvas.a, 0, 0);
    ctx.b.restore();
  }

  function draw() {
    updatePipes();
    render();
    window.requestAnimationFrame(draw);
  }

  window.addEventListener('load', setup);
  window.addEventListener('resize', resize);
  </script>


<section style="max-width:800px;margin:60px auto;padding:0 20px;font-family:Segoe UI,Roboto,Arial,sans-serif;color:#ffffff;">
  <div style="display:flex;align-items:center;gap:24px;flex-wrap:wrap;">
    <!-- Photo placeholder -->
    <div style="width:140px;height:140px;border-radius:50%;background:#ffffff url('founder-photo.jpg') center/cover no-repeat;"></div>


    <!-- Contact + title -->
    <div>
      <h2 style="margin:0;font-size:24px;">Rajiv Rampersaud</h2>
      <p style="margin:4px 0 8px;font-size:15px;color:#ffffff;">Managing Partner | Avocado Partners</p>
      <p style="margin:0;font-size:14px;color:#ffffff;">New York, US</p>
      <p style="margin:4px 0;font-size:14px;">
        <a href="tel:+19292906959" style="color:#ffffff;text-decoration:none;">+1 (929) 290-6959</a><br>
              </p>
    </div>
  </div>

  <!-- Bio text -->
  <div style="margin-top:24px;font-size:16px;line-height:1.6;color:#ffffff;">
    <p><strong>Rajiv Rampersaud</strong> is a Managing Partner of <strong>Avocado Partners</strong>, a professional services firm based in New York specializing in tax preparation, automation, and analytics. He works with individuals and small businesses to simplify compliance processes and implement efficient, data-driven solutions that reduce manual work and improve accuracy.</p>
<p>Rajiv draws on experience from Deloitte and Baker Tilly, where he supported tax engagements and developed automation workflows to enhance reporting and reconciliation. He continues to focus on making automation practical and accessible for growing organizations through his work in accounting and technology.</p>
  </div>



<div style="text-align:center; margin-top:40px;">
  <a href="index.html" style="
    display:inline-block;
    padding:12px 28px;
    background:#000;
    color:#fff;
    border:2px solid #FFFFFF;
    border-radius:8px;
    text-decoration:none;
    font-weight:600;
    font-family:Segoe UI,Roboto,Arial,sans-serif;
    letter-spacing:0.3px;
    box-shadow:0 4px 12px rgba(0,0,0,0.4);
    transition:all 0.2s ease;">
    ← Back to Home
  </a>
</div>

</section>



</body>
</html>

